#ifndef ISFImage_h
#define ISFImage_h

#include "VVISF_Base.hpp"
#include "VVISF_StringUtils.hpp"




namespace VVISF
{




/*!
\brief ISFImageInfo is the class used to represent the state and value of an image input.  The base class stores state (image width/height, whether or not the image is flipped vertically), but it does not store a value because the data needed to describe the value is going to vary from platform-to-platform and engine-to-engine.  If you actually want to store value (beyond the dimensions of the image), please subclass ISFImageInfo and pass a std::shared_ptr to your subclass to whatever accepts an ISFImageInfoRef.
\ingroup VVISF_BASIC
\relatesalso VVISF::ISFVal
*/
class ISFImageInfo	{
	public:
		uint32_t			width { 0 };	//!<	The width of the image.  If it's equal to (std::numeric_limits<uint32_t>::max()) then the runtime can provide any value for this dimension.  If it's any other value then the runtime is expected to provide an image with dimensions equal to this value.
		uint32_t			height { 0 };	//!<	The height of the image.  If it's equal to (std::numeric_limits<uint32_t>::max()) then the runtime can provide any value for this dimension.  If it's any other value then the runtime is expected to provide an image with dimensions equal to this value.
		uint32_t			depth { 0 };	//!<	The depth of the image.  If it's 0 then it's not a cubemap, it's a normal 2d image.  If it's equal to (std::numeric_limits<uint32_t>::max()) then the runtime can provide any value for this dimension.  If it's any other value then the runtime is expected to provide an image with dimensions equal to this value.
		bool				cubemap { false };
		//std::string			*pathToImage { nullptr };	//!<	Null by default, if non-nil then the value of this image needs to be generated by loading the file at this path, and the value of this string must be the full path to the image file.
		std::string			*imagePath { nullptr };
		std::vector<std::string>	*cubePaths { nullptr };
		
	public:
		ISFImageInfo(const uint32_t & inWidth, const uint32_t & inHeight) : width(inWidth), height(inHeight) {}
		ISFImageInfo(const uint32_t & inWidth, const uint32_t & inHeight, const std::string & inPath) : width(inWidth), height(inHeight)	{
			depth = 0;
			imagePath = new std::string;
			*imagePath = inPath;
		}
		ISFImageInfo(const uint32_t & inImageDimension, const std::vector<std::string> & inPaths) : width(inImageDimension), height(inImageDimension), depth(inImageDimension), cubemap(true)	{
			cubePaths = new std::vector<std::string>;
			*cubePaths = inPaths;
		}
		ISFImageInfo(const ISFImageInfo & n)	{
			width = n.width;
			height = n.height;
			depth = n.depth;
			cubemap = n.cubemap;
			if (n.imagePath != nullptr)	{
				imagePath = new std::string;
				*imagePath = *n.imagePath;
			}
			if (n.cubePaths != nullptr)	{
				cubePaths = new std::vector<std::string>;
				*cubePaths = *n.cubePaths;
			}
		}
		
		virtual ~ISFImageInfo() {
			if (imagePath != nullptr)	{
				delete imagePath;
				imagePath = nullptr;
			}
			if (cubePaths != nullptr)	{
				delete cubePaths;
				cubePaths = nullptr;
			}
		}
		
		std::string const getDescriptionString() const	{
			if (cubemap)
				return FmtString("<ISFImageInfo C %d>",width);
			else
				return FmtString("<ISFImageInfo %d x %d>",width,height);
		}
		
		bool const sizeIsValid() const	{
			static const uint32_t		maxVal = std::numeric_limits<uint32_t>::max();
			if (width == maxVal || height==maxVal)
				return false;
			return true;
		}
		
		ISFImageInfo & operator=(const ISFImageInfo & n)	{
			if (this == &n)	{
				return *this;
			}
			
			width = n.width;
			height = n.height;
			depth = n.depth;
			cubemap = n.cubemap;
			
			if (n.imagePath == nullptr)	{
				if (imagePath != nullptr)	{
					delete imagePath;
					imagePath = nullptr;
				}
			}
			else	{
				if (imagePath == nullptr)
					imagePath = new std::string;
				*imagePath = *n.imagePath;
			}
			
			if (n.cubePaths == nullptr)	{
				if (cubePaths != nullptr)	{
					delete cubePaths;
					cubePaths = nullptr;
				}
			}
			else	{
				if (cubePaths == nullptr)
					cubePaths = new std::vector<std::string>;
				cubePaths->clear();
				*cubePaths = *n.cubePaths;
			}
			
			return *this;
		}
		
		bool operator==(const ISFImageInfo & n) const	{
			bool			basicsMatch = ((width == n.width)
				&& (height == n.height)
				&& (depth == n.depth)
				&& (cubemap == n.cubemap));
			if (!basicsMatch)
				return false;
			
			bool			imagePathMatch = ( (imagePath==nullptr && n.imagePath==nullptr)
				|| (imagePath!=nullptr && n.imagePath!=nullptr && *imagePath==*n.imagePath) );
			
			//	compare the contents of 'cubePaths' and n->cubePaths
			bool			cubePathsMatch = ( (cubePaths==nullptr && n.cubePaths==nullptr)
				|| (cubePaths!=nullptr && n.cubePaths!=nullptr && *cubePaths==*n.cubePaths) );
			
			return (imagePathMatch && cubePathsMatch);
		}
		
		friend std::ostream & operator<<(std::ostream & os, const ISFImageInfo & n)	{
			os << n.getDescriptionString();
			return os;
		}
};




}




#endif /* ISFImage_h */