#ifndef ISFImage_h
#define ISFImage_h

#include "VVISF_Base.hpp"
#include "VVISF_StringUtils.hpp"




namespace VVISF
{




/*!
\brief ISFImage is the class used to represent the state and value of an image input.  By default, it stores state (image width/height), but it does not store a value because it's attempting to be a general-purpose tool.  If you actually want to store value (beyond the dimensions of the image), please subclass ISFImage and pass your subclass to whatever accepts an ISFImageRef.
\ingroup VVISF_BASIC
\relatesalso VVISF::ISFVal
*/
class ISFImage	{
	public:
		uint32_t			width { 0 };	//!<	The width of the image.  If it's equal to (std::numeric_limits<uint32_t>::max()) then the runtime can provide any value for this dimension.  If it's any other value then the runtime is expected to provide an image with dimensions equal to this value.
		uint32_t			height { 0 };	//!<	The height of the image.  If it's equal to (std::numeric_limits<uint32_t>::max()) then the runtime can provide any value for this dimension.  If it's any other value then the runtime is expected to provide an image with dimensions equal to this value.
		uint32_t			depth { 0 };	//!<	The depth of the image.  If it's 0 then it's not a cubemap, it's a normal 2d image.  If it's equal to (std::numeric_limits<uint32_t>::max()) then the runtime can provide any value for this dimension.  If it's any other value then the runtime is expected to provide an image with dimensions equal to this value.
		bool				cubemap { false };
		//std::string			*pathToImage { nullptr };	//!<	Null by default, if non-nil then the value of this image needs to be generated by loading the file at this path, and the value of this string must be the full path to the image file.
		std::string			*imagePath { nullptr };
		std::vector<std::string>	*cubePaths { nullptr };
		
	public:
		ISFImage(const uint32_t & inWidth, const uint32_t & inHeight) : width(inWidth), height(inHeight) {}
		ISFImage(const uint32_t & inWidth, const uint32_t & inHeight, const std::string & inPath) : width(inWidth), height(inHeight)	{
			depth = 0;
			imagePath = new std::string;
			*imagePath = inPath;
		}
		ISFImage(const uint32_t & inImageDimension, const std::vector<std::string> & inPaths) : width(inImageDimension), height(inImageDimension), depth(inImageDimension), cubemap(true)	{
			cubePaths = new std::vector<std::string>;
			*cubePaths = inPaths;
		}
		ISFImage(const ISFImage & n)	{
			width = n.width;
			height = n.height;
			depth = n.depth;
			cubemap = n.cubemap;
			if (n.imagePath != nullptr)	{
				imagePath = new std::string;
				*imagePath = *n.imagePath;
			}
			if (n.cubePaths != nullptr)	{
				cubePaths = new std::vector<std::string>;
				*cubePaths = *n.cubePaths;
			}
		}
		
		virtual ~ISFImage() {
			if (imagePath != nullptr)	{
				delete imagePath;
				imagePath = nullptr;
			}
			if (cubePaths != nullptr)	{
				delete cubePaths;
				cubePaths = nullptr;
			}
		}
		
		std::string const getDescriptionString() const	{
			if (cubemap)
				return FmtString("<ISFImage C %d>",width);
			else
				return FmtString("<ISFImage %d x %d>",width,height);
		}
		
		friend std::ostream & operator<<(std::ostream & os, const ISFImage & n)	{
			os << n.getDescriptionString();
			return os;
		}
};




}




#endif /* ISFImage_h */